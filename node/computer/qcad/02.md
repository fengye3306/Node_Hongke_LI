


## 图元系统架构大纲

*qcad*中，底层图元均由`RShape`基类派生而来，实现*Point*点、*Line*线，*Arc*圆弧、*Circle*圆、*Ellipse*椭圆，*Polyline*多段线，*Spline*样条曲线，*Triangle*三角形、*XLine*构造线、*Ray*射线。  
构造线(XLine)在两个方向上无限延伸的直线，通常用于辅助绘图，射线(Ray)是从一个点开始单方向无限延伸的直线。


## RShape 接口完整解析

> 基础类型与枚举

* 枚举类型，定义所有支持的图元类型 `RShape::Type`：
  - `Unknown` - 未知类型
  - `Point` - 点
  - `Line` - 直线
  - `Arc` - 圆弧
  - `Circle` - 圆
  - `Ellipse` - 椭圆
  - `Polyline` - 多段线
  - `Spline` - 样条曲线
  - `Triangle` - 三角形
  - `XLine` - 构造线
  - `Ray` - 射线

* 默认构造函数 `RShape()`
* 虚析构函数 `virtual ~RShape()`

> 类型识别与查询

* 获取图元类型 `virtual RShape::Type getShapeType() const`
* 判断是否为点 `static bool isPointShape(const RShape& s)`
* 判断是否为直线 `static bool isLineShape(const RShape& s)`
* 判断是否为圆弧 `static bool isArcShape(const RShape& s)`
* 判断是否为圆 `static bool isCircleShape(const RShape& s)`
* 判断是否为椭圆 `static bool isEllipseShape(const RShape& s)`
* 判断是否为完整椭圆 `static bool isFullEllipseShape(const RShape& s)`
* 判断是否为多段线 `static bool isPolylineShape(const RShape& s)`
* 判断是否为样条曲线 `static bool isSplineShape(const RShape& s)`
* 判断是否为三角形 `static bool isTriangleShape(const RShape& s)`
* 判断是否为构造线 `static bool isXLineShape(const RShape& s)`
* 判断是否为射线 `static bool isRayShape(const RShape& s)`

> 基础属性与验证

* 验证形状是否有效 `virtual bool isValid() const`
* 克隆形状（纯虚函数） `virtual QSharedPointer<RShape> clone() const`

> 数学特性

* 是否为插值计算图元 `virtual bool isInterpolated() const`

*插值计算图元指需要通过离散点采样近似求解的图元，如样条曲线、Bézier曲线等*

> 几何计算接口

* 获取最近点 `virtual RVector getClosestPointOnShape(const RVector& p, bool limited = true, double strictRange = RMAXDOUBLE) const`
* 获取包围盒（纯虚函数） `virtual RBox getBoundingBox() const`
* 获取长度（纯虚函数） `virtual double getLength() const`
* 相等性比较 `virtual bool equals(const RShape& other, double tolerance=RS::PointTolerance) const`

> 距离与向量计算

* 获取到点的向量（纯虚函数） `virtual RVector getVectorTo(const RVector& point, bool limited = true, double strictRange = RMAXDOUBLE) const`
* 计算到点的距离 `virtual double getDistanceTo(const RVector& point, bool limited = true, double strictRange = RMAXDOUBLE) const`
* 计算到多点集的最大距离 `virtual double getMaxDistanceTo(const QList<RVector>& points, bool limited = true, double strictRange = RMAXDOUBLE) const`
* 获取从端点到点的向量 `virtual RVector getVectorFromEndpointTo(const RVector& point) const`

> 位置关系判断

* 判断点是否在形状上 `virtual bool isOnShape(const RVector& point, bool limited = true, double tolerance = RDEFAULT_TOLERANCE_1E_MIN4) const`
* 筛选在形状上的点 `virtual QList<RVector> filterOnShape(const QList<RVector>& pointList, bool limited = true, double tolerance = RDEFAULT_TOLERANCE_1E_MIN4) const`
* 判断点在形状的哪一侧 `virtual RS::Side getSideOfPoint(const RVector& point) const`

> 关键点获取

* 获取端点（纯虚函数） `virtual QList<RVector> getEndPoints() const`
* 获取中点（纯虚函数） `virtual QList<RVector> getMiddlePoints() const`
* 获取中心点（纯虚函数） `virtual QList<RVector> getCenterPoints() const`
* 获取圆弧参考点 `virtual QList<RVector> getArcReferencePoints() const`
* 获取形状上的任意点 `virtual RVector getPointOnShape() const`
* 获取离散点云（纯虚函数） `virtual QList<RVector> getPointCloud(double segmentLength) const`

> 参数化几何接口

* 获取距端点指定距离的点（纯虚函数） `virtual QList<RVector> getPointsWithDistanceToEnd(double distance, int from = RS::FromAny) const`
* 获取距起点指定距离的点 `virtual RVector getPointWithDistanceToStart(double distance) const`
* 获取距终点指定距离的点 `virtual RVector getPointWithDistanceToEnd(double distance) const`
* 获取指定距离处的角度 `virtual double getAngleAt(double distance, RS::From from = RS::FromStart) const`
* 获取指定点处的角度 `virtual double getAngleAtPoint(const RVector& pos) const`
* 获取百分比位置的点 `virtual RVector getPointAtPercent(double p) const`
* 获取百分比位置的角度 `virtual double getAngleAtPercent(double p) const`

> 距离计算

* 获取点到起点的距离 `virtual double getDistanceFromStart(const RVector& p) const`
* 获取点到起点的所有可能距离 `virtual QList<double> getDistancesFromStart(const RVector& p) const`

> 相交计算

* 判断是否相交 `virtual bool intersectsWith(const RShape& other, bool limited = true) const`
* 获取相交点 `QList<RVector> getIntersectionPoints(const RShape& other, bool limited = true, bool same = false, bool force = false) const`
* 获取自相交点 `virtual QList<RVector> getSelfIntersectionPoints(double tolerance=RS::PointTolerance) const`
* 静态相交点计算 `static QList<RVector> getIntersectionPoints(const RShape& shape1, const RShape& shape2, bool limited = true, bool same = false, bool force = false)`

> 方向性接口

* 是否有明确方向 `virtual bool isDirected() const`
* 起点方向角度 `virtual double getDirection1() const`
* 终点方向角度 `virtual double getDirection2() const`
* 获取起点 `virtual RVector getStartPoint() const`
* 获取终点 `virtual RVector getEndPoint() const`
* 获取中点 `virtual RVector getMiddlePoint() const`

> 形状编辑操作

* 反转形状方向 `virtual bool reverse()`
* 修剪起点 `virtual bool trimStartPoint(const RVector& trimPoint, const RVector& clickPoint = RVector::invalid, bool extend = false)`
* 按距离修剪起点 `virtual bool trimStartPoint(double trimDist)`
* 修剪终点 `virtual bool trimEndPoint(const RVector& trimPoint, const RVector& clickPoint = RVector::invalid, bool extend = false)`
* 按距离修剪终点 `virtual bool trimEndPoint(double trimDist)`
* 确定修剪端 `virtual RS::Ending getTrimEnd(const RVector& trimPoint, const RVector& clickPoint)`

> 几何变换

* 平移（纯虚函数） `virtual bool move(const RVector& offset)`
* 旋转（纯虚函数） `virtual bool rotate(double rotation, const RVector& center = RDEFAULT_RVECTOR)`
* 统一缩放 `virtual bool scale(double scaleFactor, const RVector& center = RVector())`
* 非均匀缩放（纯虚函数） `virtual bool scale(const RVector& scaleFactors, const RVector& center = RVector())`
* 镜像（纯虚函数） `virtual bool mirror(const RLine& axis)`
* 水平翻转 `virtual bool flipHorizontal()`
* 垂直翻转 `virtual bool flipVertical()`
* 拉伸形状（矩形区域） `virtual bool stretch(const RBox& area, const RVector& offset)`
* 拉伸形状（多段线区域） `virtual bool stretch(const RPolyline& area, const RVector& offset)`

> 维度处理

* 将形状压平到 X/Y 平面 `virtual void to2D()`
* 设置Z坐标值 `virtual void setZ(double z)`

> 统一属性访问接口

* 获取向量属性 `virtual QList<RVector> getVectorProperties() const`
* 获取整数属性 `virtual QList<int> getIntProperties() const`
* 获取浮点属性 `virtual QList<double> getDoubleProperties() const`
* 获取布尔属性 `virtual QList<bool> getBoolProperties() const`

> 变换支持

* 获取应用变换后的形状 `virtual QSharedPointer<RShape> getTransformed(const QTransform& transform) const`

> 形状操作工具

* 生成偏移形状 `virtual QList<QSharedPointer<RShape> > getOffsetShapes(double distance, int number, RS::Side side, const RVector& position = RVector::invalid)`
* 在指定点处分割形状 `virtual QList<QSharedPointer<RShape> > splitAt(const QList<RVector>& points) const`
* 静态偏移直线 `static QList<QSharedPointer<RShape> > getOffsetLines(const RShape& shape, double distance, int number, RS::Side side, const RVector& position = RVector::invalid)`
* 静态偏移圆弧 `static QList<QSharedPointer<RShape> > getOffsetArcs(const RShape& shape, double distance, int number, RS::Side side, const RVector& position = RVector::invalid)`
* 反转形状列表 `static QList<QSharedPointer<RShape> > getReversedShapeList(const QList<QSharedPointer<RShape> >& shapes)`
* 修剪形状 `static QList<QSharedPointer<RShape> > trim(const RShape& trimShape, const RVector& trimClickPos, const RShape& limitingShape, const RVector& limitingClickPos, bool trimBoth, bool samePolyline)`
* 圆角处理 `static QList<QSharedPointer<RShape> > roundCorners(const QList<QSharedPointer<RShape> >& shapes, double radius)`
* 形状圆角 `static QList<QSharedPointer<RShape> > roundShapes(const QSharedPointer<RShape> shape1, const RVector& clickPos1, const QSharedPointer<RShape> shape2, const RVector& clickPos2, bool trim, bool samePolyline, double radius, const RVector& pos)`
* 将形状列表转换为多段线 `static QList<RPolyline> getPolylines(const QList<QSharedPointer<RShape> >& shapes)`
* 获取有序形状列表 `static QList<QSharedPointer<RShape> > getOrderedShapes(const QList<QSharedPointer<RShape> >& shapes)`
* 形状排序 `static bool order(QList<QList<QSharedPointer<RShape> > >& boundary)`

> 类型转换

* 构造线转射线 `static QSharedPointer<RShape> xLineToRay(QSharedPointer<RShape> shape)`
* 射线转直线 `static QSharedPointer<RShape> rayToLine(QSharedPointer<RShape> shape)`
* 椭圆转换 `static QSharedPointer<RShape> ellipseToArcCircleEllipse(const REllipse& ellipse)`

> 特殊计算支持

* 圆弧缩放 `static QSharedPointer<RShape> scaleArc(const RShape& shape, const RVector& scaleFactors, const RVector& center = RDEFAULT_RVECTOR)`
* 椭圆分解，函数会根据椭圆的特性返回最合适的表示形式：可能是圆弧（RArc）、圆（RCircle）或椭圆（REllipse）。 `static QSharedPointer<RShape> transformArc(const RShape& shape, RShapeTransformation& transformation)`

> 相交计算静态方法

* 直线与直线相交 `static QList<RVector> getIntersectionPointsLL(const RLine& line1, const RLine& line2, bool limited = true)`
* 直线与圆弧相交 `static QList<RVector> getIntersectionPointsLA(const RLine& line1, const RArc& arc2, bool limited = true)`
* 直线与圆相交 `static QList<RVector> getIntersectionPointsLC(const RLine& line1, const RCircle& circle2, bool limited = true)`
* 直线与椭圆相交 `static QList<RVector> getIntersectionPointsLE(const RLine& line1, const REllipse& ellipse2, bool limited = true)`
* 直线与三角形相交 `static QList<RVector> getIntersectionPointsLT(const RLine& line1, const RTriangle& triangle2, bool limited = true)`
* 直线与样条曲线相交 `static QList<RVector> getIntersectionPointsLS(const RLine& line1, const RSpline& spline2, bool limited = true)`
* 圆弧与圆弧相交 `static QList<RVector> getIntersectionPointsAA(const RArc& arc1, const RArc& arc2, bool limited = true)`
* 圆弧与圆相交 `static QList<RVector> getIntersectionPointsAC(const RArc& arc1, const RCircle& circle2, bool limited = true)`
* 圆与圆相交 `static QList<RVector> getIntersectionPointsCC(const RCircle& circle1, const RCircle& circle2)`
* 样条曲线与样条曲线相交 `static QList<RVector> getIntersectionPointsSS(const RSpline& spline1, const RSpline& spline2, bool limited = true, bool same = false, double tolerance=RS::PointTolerance)`

> 调试与工具

* 获取错误码 `static int getErrorCode()`
* 调试输出 `void dump() const`
* 打印函数 `virtual void print(QDebug dbg) const`

> 代理模式支持

* 判断是否有代理 `static bool hasProxy()`
* 设置形状代理 `static void setShapeProxy(RShapeProxy* p)`
* 获取形状代理 `static RShapeProxy* getShapeProxy()`

*通过形状代理模式支持扩展功能，提供灵活的架构设计*